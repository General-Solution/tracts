from tracts.haploid import Haploid
from tracts.chromosome import Chropair, Chrom

import tkinter as tk
import numpy as np


class Indiv:
    """ The class of diploid individuals. An individual can hence be though of
        as a list of pairs of chromosomes. Equivalently, a diploid individual
        is a pair of haploid individuals.

        Thus, it is possible to construct instances of this class from a pair
        of instances of the haploid class, as well as directly from a sequence
        of chropair instances.

        The interface for loading individuals from files uses the
        haploid-oriented approach, since individual .bed files describe only
        one haplotype. The loading process is thus the following:

        1. load haploid individuals for each haplotype
        2. combine the haploid individuals into a diploid individual
    """

    @staticmethod
    def from_haploids(haps: list[Haploid]):
        if len(haps) != 2:
            raise ValueError('Two haplotypes must given to construct '
                             'a diploid individual')

        chroms = [Chropair(t) for t in zip(*[hap.chroms for hap in haps])]
        return Indiv(chroms=chroms, Ls=haps[0].Ls)

    @staticmethod
    def from_files(paths, selectchrom=None, name=None):
        """ Construct a diploid individual from two files, which describe the
            individuals haplotypes.
        """
        if len(paths) != 2:
            raise ValueError('more than two paths supplied to construct '
                             'a diploid individual')

        return Indiv.from_haploids(
            [Haploid.from_file(path, name=name, selectchrom=selectchrom)
             for path in paths])

    def __init__(self, Ls=None, label="POP", fname=None, labs=("_A", "_B"),
                 selectchrom=None, chroms=None, name=None):
        """ Construct a diploid individual. There are several ways to build
            individuals, either from files, from existing data, or
            programmatically.

            The most straightforward way to build an individual is from
            existing data, by supplying only the "Ls" and "chroms" arguments.

            Ls (default: None, type: list of floats):
                The lengths of the chromosomes in the order in which they
                appear in "chroms".
            chroms (default: None, type: list of chropair objects):
                The chromosome pairs that make up this individual. See the
                documentation for "chropair".

            If "Ls" is given, but "chroms" is not, then chromosomes consisting
            each of a single tract will be created with the label "label" and
            lengths drawn from "Ls".

            label (default: "POP", type: string):
                The label to use for building single-tract chromosomes when no
                other data is given to buid this individual.

            (deprecated) If the "fname" argument is given, the constructor will
            perform path manipulation involving the components of "fname" and
            "labs" to generate file names that are commonly used when dealing
            with .bed files.

            fname (default: None, type: 2-tuple of strings):
                Paths are generated by concatenating the first component of
                "fname", each label from "labs" in turn, and the second
                component of "fname".
                > fname[0] + lab + fname[1] for lab in labs

            labs (default: ("_A", "_B"), type: 2-tuple of strings):
                The labels used to identify maternal and paternal haplotypes in
                the paths leading to .bed files.

            selectchrom (default: None, type: list of integers):
                This argument is forwarded as-is to haploid.from_file. It acts
                as a filter on the chromosomes to load. The default value of
                "None" selects all chromosomes.

            Finally, some arguments are very general and are not involved in
            the analysis of the tracts.

            name (default: None, type: string):
                An identifier for this individual.

            The facilities in this constructor for loading individuals from
            files are deprecated. It is recommended to instead use the static
            methods from_files or from_haploids.
        """
        if fname is None:
            self.Ls = Ls
            if chroms is None:
                self.chroms = [Chropair(chropair_len=length, label=label) for length in Ls]
            else:
                self.chroms = chroms
        else:
            fnames = [fname[0] + lab + fname[1] for lab in labs]
            i = Indiv.from_files(fnames, selectchrom)
            self.name = fname[0].split('/')[-1]
            self.chroms = i.chroms
            self.Ls = i.Ls
        self.canvas = None

    def plot(self, colordict, win=None):
        """Plot an individual. colordict is a dictionary mapping population label to
        a set of colors. E.g.:
        colordict = {"CEU":'r',"YRI":b}
        """
        if win is None:
            win = tk.Tk()
        self.canvas = tk.Canvas(
            win, width=250, height=len(self.Ls) * 30, bg='white')

        for i in range(len(self.chroms)):
            self.chroms[i].plot(self.canvas, colordict, height=int(i * .3))

        self.canvas.pack(expand=tk.YES, fill=tk.BOTH)

        return win

    def create_gamete(self):
        lsc = [chpair.recombine() for chpair in self.chroms]
        return Haploid(self.Ls, lsc)

    def applychrom(self, func):
        """ Apply the function `func` to each chromosome of the individual. """
        return map(lambda c: c.applychrom(func), self.chroms)

    def ancestryAmt(self, ancestry):
        """ Calculate the total length of the genome in segments of the given
            ancestry.
            """
        return np.sum(
            t.len()
            for t
            in self.iflatten()
            if t.label == ancestry)

    def ancestryProps(self, ancestries):
        """ Calculate the proportion of the genome represented by the given
            ancestries.
            """

        # We want to compute the sum of all the tract lengths as well as the
        # sum of the tract lengths that match ancestries given in the list
        # "ancestries", so for each tract, in this individual, we compute its
        # length as well as a tuple that represents which ancestry that tract
        # belongs to.
        gen = ((t.len(), [t.len() if t.label == a else 0 for a in ancestries])
               for t in self.iflatten())

        all_lengths, all_ancestry_lengths = zip(*gen)
        total_length = float(np.sum(all_lengths))
        ancestry_sums = map(np.sum, zip(*all_ancestry_lengths))

        return [ancestry_sum * 1. / total_length for ancestry_sum in ancestry_sums]

    def ancestryPropsByChrom(self, ancestries):
        dat = self.applychrom(Chrom.tractlengths)
        dictamt = {}
        nc = len(list(dat))
        for ancestry in ancestries:
            lsamounts = []
            for chromv in dat:
                lsamounts.append(np.sum([segment[1]
                                         for copy in chromv
                                         for segment in copy
                                         if segment[0] == ancestry]))
            dictamt[ancestry] = lsamounts
        tots = [np.sum(
            [dictamt[ancestry][i]
             for ancestry in ancestries])
            for i in range(nc)]

        return [[dictamt[ancestry][i] * 1. / tots[i]
                 for i in range(nc)]
                for ancestry in ancestries]

    def iflatten(self):
        """ Lazily flatten this individual to the tract level.  """
        for _chrom in self.chroms:
            for _copy in _chrom.copies:
                for _tract in _copy.tracts:
                    yield _tract

    def flat_imap(self, f):
        """ Lazily map a function over the full underlying structure of this
            individual.
            The function must accept 3 parameters:
                chrom: the chromosome pair containing the tract
                copy: the chromosome containing the tract
                tract: the tract itself
        """
        for _chrom in self.chroms:
            for _copy in _chrom.copies:
                for _tract in _copy.tracts:
                    yield f(_chrom, _copy, _tract)

    def __iter__(self):
        return self.chroms.__iter__()

    def __getitem__(self, index):
        return self.chroms[index]

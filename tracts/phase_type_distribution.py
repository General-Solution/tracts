import itertools

import numpy as np
import numpy.typing as npt
import scipy
from scipy.special import gammaln


def distribution_scaling_factor(population_proportion, S, S0_inv=None, alpha=None):
    """
    This is equal to 2 times the ancestry proportion divided by the expected length of a tract on an
    infinite chromosome.
    Still not clear on the theory behind this, but it agrees with tracts 1 and with simulations
    """
    if S0_inv is None:
        S0_inv = np.linalg.inv(S).sum(1)
    if alpha is None:
        alpha = np.ones(len(S0_inv)) / S0_inv
    return -2 * population_proportion / np.dot(alpha, S0_inv)


def normalization_factor_2(L, S, S0_inv=None, alpha=None):
    """Computes the normalization factor Z from S0_inv and chromosome length L
    """
    if S0_inv is None:
        S0_inv = np.linalg.inv(S).sum(1)
    if alpha is None:
        alpha = np.ones(len(S0_inv)) / S0_inv
    return L - np.dot(alpha, S0_inv)


class PhaseTypeDistribution:
    """
    A class representing the phase-type distribution of tracts
    generated by a given migration matrix.
    """

    def __init__(self, migration_matrix, max_remaining_tracts=1e-5):
        self.migration_matrix = migration_matrix
        self.max_remaining_tracts = max_remaining_tracts
        """
        The phase-type distribution should have a transition matrix for each population.
        In a given transition matrix, transient states correspond to staying within that population,
        while the absorbing state is moving to a tract of different ancestry.
        """
        self.num_populations = migration_matrix.shape[1]
        self.survival_factors = self.get_survival_factors()
        self.num_generations = len(migration_matrix)
        self.t0_proportions = np.sum(self.migration_matrix * np.transpose([self.survival_factors]), axis=0)
        # Technically these are submatrices of the full transition matrix
        self.transition_matrices = [0] * self.num_populations

        # list of initial probabilities for each state.
        self.alpha_list = [0] * self.num_populations

        self.all_states = migration_matrix.nonzero()
        # all_states[0] contains the migration times and all_states[1] contains the migration populations
        # In other words, (all_states[0][i], all_states[1][i]) gives the ith (time, pop) migration

        # num_states = len(self.all_states[0])

        # In a continuous-time markov chain, diagonal entries
        # are normalized to be equal to 1 - (probability of no-transition)
        # Because self-transitioning and no-transitioning is considered identical.
        self.full_transition_matrix = self.get_transition_matrix()
        if not np.all(np.isreal(self.full_transition_matrix)):
            print(f'Transition matrix is complex.\n{self.full_transition_matrix}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        self.full_transition_matrix -= np.diag(self.full_transition_matrix.sum(axis=1))
        self.maxLen = None

        # equilibrium_distribution = self.get_equilibrium_distribution()
        self.equilibrium_distribution = self.get_equilibrium_distribution()

        # The following lines have some numpy magic to calculate the alpha values as efficiently as possible.
        # [:,None] takes the transpose; a population list [0,1,2] becomes [[0],[1],[2]].
        # When cast against the row-vector list of states,
        # the result is an S*P matrix where S is the number of states and P is the number of populations
        # An element i,j is True if state i is from population j and False if not.
        state_filters = self.all_states[1] == np.arange(self.num_populations)[:, None]

        # equilibrium_distribution*(1-state_filters) zeroes out the equilibrium distribution
        # for the focal states in each row.
        # Then dotting it with self.full_transition_matrix applies the transition matrix to each row.
        # The values that land in the previously empty focal states correspond to the values of alpha
        # So [alpha[state_filter] for alpha, state_filter in zip(...)] Goes row by row and
        # collects those values into the final array
        # And then we apply the following function to make sure the states sum to 1
        # This may be worth omitting if the end probability distributions are going to be normalized anyway
        def _normalize_sum_to_1(array):
            return array / array.sum()

        self.alpha_list = [_normalize_sum_to_1(alpha[state_filter]) for alpha, state_filter in
                           zip(np.dot(self.equilibrium_distribution * (1 - state_filters),
                                      self.full_transition_matrix),
                               state_filters)]

        self.transition_matrices = [self.full_transition_matrix[state_filter][:, state_filter] for state_filter in
                                    state_filters]

        # print(self.transition_matrices)
        # Row sum of the transition submatrices
        # This is S*(1^T), which shows up in the probability density function.
        self.S0_list = [-np.sum(transition_matrix, axis=1) for transition_matrix in self.transition_matrices]

        # Row sum of inverse of the transition submatrix.
        # This is equal to (S^-1)*(1^T), which shows up frequently in CDF calculation
        self.inverse_S0_list = [np.sum(np.linalg.inv(transition_matrix), axis=1) for transition_matrix in
                                self.transition_matrices]

    def get_survival_factors(self):
        """
        Takes a migration matrix of generations T and returns a list of length T,
        which is the probability of a migrant allele from that generation surviving to the present
        """
        survival_factors = np.ones(len(self.migration_matrix))
        for generation_number in range(1, len(self.migration_matrix)):
            survival_factors[generation_number] = survival_factors[generation_number - 1] * (
                    1 - sum(self.migration_matrix[generation_number - 1]))
        return survival_factors

    def get_time_transition_factor(self, initial_time, final_time):
        return sum([self.survival_factors[final_time] / self.survival_factors[T + 1] for T in
                    range(1, min(initial_time, final_time))])

    def get_discrete_transition_matrix(self):
        return np.array([[self.migration_matrix[dest_time, dest_pop] * self.get_time_transition_factor(initial_time,
                                                                                                       dest_time) for
                          dest_time, dest_pop in zip(self.all_states[0], self.all_states[1])] for initial_time in
                         self.all_states[0]])

    def get_transition_matrix(self):
        return np.array([[self.migration_matrix[dest_time, dest_pop] * self.get_time_transition_factor(initial_time,
                                                                                                       dest_time) for
                          dest_time, dest_pop in zip(self.all_states[0], self.all_states[1])] for initial_time in
                         self.all_states[0]])

    def get_equilibrium_distribution(self):
        transition_matrix_eigs = np.linalg.eig(self.full_transition_matrix.transpose())
        try:
            result_vector = [eigenvector for eigenvalue, eigenvector in
                             zip(transition_matrix_eigs[0], np.transpose(transition_matrix_eigs[1])) if
                             np.isclose(eigenvalue, 0)][0]
            result_vector = result_vector / np.linalg.norm(result_vector, ord=1)
            return result_vector
        except IndexError as _:
            raise Exception(
                'Equilibrium distribution could not be calculated. The transition matrix does not have a 0 eigenvalue.')

    def get_equilibrium_distribution_v2(self):

        # This may be a faster method to compute the equilibrium distribution. Will need testing.
        return np.transpose(scipy.linalg.null_space(np.transpose(self.full_transition_matrix)))

    def get_TpopTau(self, t, pop, Tau):
        # Confirmation method for calculating equivalent of TpopTau from demographic_model.
        # Just checking that values are the same.
        return self.survival_factors[t] / self.survival_factors[Tau + 1] * self.migration_matrix[t, pop]

    def density_function(self, x, population_number):
        transition_matrix = self.transition_matrices[population_number]
        alpha = [1 / (len(transition_matrix))] * (len(transition_matrix))
        # print(alpha)
        # print(transition_matrix)
        return np.dot(np.dot(alpha, scipy.linalg.expm(x * transition_matrix)), self.S0_list[population_number])

    def cumulative_distribution_function(self, x, population_number):
        transition_matrix = self.transition_matrices[population_number]
        alpha = [1 / (len(transition_matrix))] * (len(transition_matrix))
        return 1 - sum(np.dot(alpha, scipy.linalg.expm(x * transition_matrix)))

    def tractlength_histogram(self, population_number: int, bins: npt.ArrayLike):
        """
        Gets the tractlength histogram using the cumulative distribution function.
        """
        CDF_values = np.zeros(len(bins) + 1)
        for bin_number, bin_val in enumerate(bins):
            CDF_values[bin_number] = self.cumulative_distribution_function(bin_val, population_number)

        CDF_values[-1] = CDF_values[-2]
        return np.diff(CDF_values)

    def tractlength_histogram_PDF(self, population_number: int, bins: npt.ArrayLike):
        tracts_per_bin = np.zeros(len(bins))
        for bin_number in range(len(bins) - 1):
            midpoint = (bins[bin_number] + bins[bin_number + 1]) / 2.
            bin_width = bins[bin_number + 1] - bins[bin_number]
            tracts_per_bin[bin_number] = max(self.density_function(midpoint, population_number) * bin_width, 1e-17)

        # tracts_per_bin.append(max(self.totalfull, 1e-17))
        return tracts_per_bin

    def tractlength_histogram_windowed(self, population_number: int, bins: npt.ArrayLike, L: float,
                                       exp_Sx_per_bin: npt.ArrayLike = None) -> npt.ArrayLike:
        """Calculates the tractlength histogram on a window L
        """
        CDF_values = np.zeros(len(bins) + 1)
        S = self.transition_matrices[population_number]
        alpha = self.alpha_list[population_number]
        S0_inv = self.inverse_S0_list[population_number]
        scale = distribution_scaling_factor(self.t0_proportions[population_number], S, S0_inv=S0_inv, alpha=alpha)
        for bin_number, bin_val in enumerate(bins):
            # maybe precompute this further up?
            if exp_Sx_per_bin is None:
                exp_Sx = scipy.linalg.expm(bin_val * S)
            else:
                exp_Sx = exp_Sx_per_bin[bin_number]
            if bin_val > L:
                CDF_values[bin_number] = CDF_values[bin_number - 1]
            else:
                CDF_values[bin_number] = (
                        self.inner_CDF(bin_val, L, S, exp_Sx, alpha, S0_inv) + self.outer_CDF(bin_val, L, S, exp_Sx,
                                                                                              alpha, S0_inv))

        CDF_values[-1] = CDF_values[-2] + self.full_PDF(L, S, alpha=alpha, S0_inv=S0_inv)
        if not np.all(np.isreal(CDF_values)):
            print(f'CDF is complex.\n{CDF_values}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        return np.real(np.diff(CDF_values) * scale)

    def tractlength_histogram_multi_windowed(self, population_number: int, bins: npt.ArrayLike,
                                             chrom_lengths: npt.ArrayLike) -> npt.ArrayLike:
        """Calculates the tractlength histogram on multiple chromosomes of lengths [chrom_lengths]
        """
        histogram = np.zeros(len(bins))
        S = self.transition_matrices[population_number]
        exp_Sx_per_bin = [0] * len(bins)
        for bin_number, bin_val in enumerate(bins):
            exp_Sx_per_bin[bin_number] = scipy.linalg.expm(bin_val * S)
        for L in chrom_lengths:
            new_histogram = self.tractlength_histogram_windowed(population_number, bins, L, exp_Sx_per_bin)
            histogram += new_histogram
        return histogram

    def expectperbin(self, Ls, pop, bins, nsamp_list=None):
        """
        Backwards compatibility with old tracts syntax
        """
        return self.tractlength_histogram_multi_windowed(pop, bins, Ls)

    def normalization_factor(self, L, S, S0_inv=None, alpha=None, exp_SL=None):
        """Computes the normalization factor Z from S0_inv and chromosome length L
        """
        if S0_inv is None:
            S0_inv = np.linalg.inv(S).sum(1)
        if alpha is None:
            alpha = np.ones(len(S0_inv)) / S0_inv
        if exp_SL is None:
            exp_SL = scipy.linalg.expm(L * S)
        return (self.inner_CDF(L, L, S, alpha=alpha, S0_inv=S0_inv, exp_Sx=exp_SL) +
                self.outer_CDF(L, L, S, exp_Sx=exp_SL, alpha=alpha, S0_inv=S0_inv) +
                self.full_CDF(L, S, exp_SL=exp_SL, alpha=alpha, S0_inv=S0_inv))

    def inner_CDF(self, x, L, S, exp_Sx=None, alpha=None, S0_inv=None):
        """ Calculate the CDF of tractlengths on a window L
            S is the transition submatrix
            Z is the normalization factor
            Accepts precomputed values for e^Sx, e^SL, and Z
        """
        if x > L:
            raise Exception('Cannot find tracts of length greater than L in a window L')
        if exp_Sx is None:
            exp_Sx = scipy.linalg.expm(x * S)
        if alpha is None:
            alpha = np.ones(len(S)) / len(S)
        if S0_inv is None:
            S0_inv = np.linalg.inv(S).sum(1)
        n_states = len(alpha)
        inner_val = -np.dot(alpha, np.dot((exp_Sx - np.identity(n_states)), L + S0_inv) - np.sum(x * exp_Sx, 1))
        if not np.all(np.isreal(inner_val)):
            print(f'Inner CDF is complex.\n{inner_val}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        return np.real(inner_val)

    def outer_CDF(self, x, L, S, exp_Sx=None, alpha=None, S0_inv=None):
        """ Calculate the length distribution of tract lengths hitting a single
            chromosome edge. """
        if x > L:
            raise Exception('Cannot find tracts of length greater than L in a window L')
        if exp_Sx is None:
            exp_Sx = scipy.linalg.expm(x * S)
        if alpha is None:
            alpha = np.ones(len(S)) / len(S)
        if S0_inv is None:
            S0_inv = np.linalg.inv(S).sum(1)
        n_states = len(alpha)
        outer_val = 2 * np.dot(alpha, np.dot(exp_Sx - np.identity(n_states), S0_inv))
        if not np.all(np.isreal(outer_val)):
            print(f'Outers CDF is complex.\n{outer_val}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        return np.real(outer_val)

    def full_CDF(self, L, S, exp_SL=None, alpha=None, S0_inv=None):
        """ The expected fraction of full-chromosome tracts, p. 63 May 24,
            2011. """
        if exp_SL is None:
            exp_SL = scipy.linalg.expm(L * S)
        if alpha is None:
            alpha = np.ones(len(S)) / len(S)
        if S0_inv is None:
            S0_inv = np.linalg.inv(S).sum(1)
        full_val = -np.dot(alpha, np.dot(exp_SL, S0_inv))
        if not np.all(np.isreal(full_val)):
            print(f'full_CDF is complex.\n{full_val}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        return np.real(full_val)

    def full_PDF(self, L, S, exp_SL=None, alpha=None, S0_inv=None):
        """ The expected fraction of full-chromosome tracts, p. 63 May 24,
            2011. """
        if exp_SL is None:
            exp_SL = scipy.linalg.expm(L * S)
        if alpha is None:
            alpha = np.ones(len(S)) / len(S)
        if S0_inv is None:
            S0_inv = np.linalg.inv(S).sum(1)
        full_val = -np.dot(alpha, np.dot(exp_SL, S0_inv))
        if not np.all(np.isreal(full_val)):
            print(f'full_PDF is complex.\n{full_val}')
            print(f'Migration matrix:\n{self.migration_matrix}')
        return np.real(full_val)

    def loglik(self, bins, Ls, data, num_samples, cutoff=0):
        """ Calculate the maximum-likelihood in a Poisson Random Field. Last
            bin of data is the number of whole-chromosome. """
        # print('Getting the likelihood of the model.')
        self.maxLen = max(Ls)
        # define bins that contain all possible values
        # bins=np.arange(0,self.maxLen+1./2./float(npts),self.maxLen/float(npts))
        # ll = 0
        # print(f'npops: {self.npops}')
        predicted_tractlength_histogram = None
        pop = None
        for pop in range(self.num_populations):
            predicted_tractlength_histogram = self.tractlength_histogram_multi_windowed(pop, bins, Ls)
            # print(f'pop: {pop}, models: {models}')
            # print(f'data: {data}')
        # TODO: Only use the last value of predicted_tractlength_histogram?
        return sum(-num_samples * predicted_tracts + data_tracts * np.log(num_samples * predicted_tracts) - gammaln(
            data_tracts + 1.)
                   for data_tracts, predicted_tracts in itertools.islice(
            zip(data[pop], predicted_tractlength_histogram),
            cutoff, len(predicted_tractlength_histogram) - 1)
                   )
